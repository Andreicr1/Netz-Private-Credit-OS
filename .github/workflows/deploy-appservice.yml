name: Deploy (Azure App Service)

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-appservice-main
  cancel-in-progress: true

env:
  # Prefer GitHub repo/environment variables, but keep safe defaults so the workflow
  # remains runnable even if vars are not configured.
  AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP || 'Netz-International' }}
  AZURE_WEBAPP_NAME: ${{ vars.AZURE_WEBAPP_NAME || 'netz-prod-api' }}
  AZURE_WEBAPP_URL: ${{ vars.AZURE_WEBAPP_URL || 'https://netz-prod-api.azurewebsites.net' }}
  # Optional: when set, the workflow will configure authsettingsV2 to allow anonymous.
  # Leave unset to skip that management operation.
  SWA_CLIENT_ID: ${{ vars.SWA_CLIENT_ID }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Build Python dependencies (prebuilt)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install -U pip
          rm -rf .python_packages
          # IMPORTANT: Azure App Service Linux images can run older glibc than the GitHub runner.
          # If we build native deps (e.g., cryptography) on the runner, we can ship binaries that
          # fail at runtime with errors like: "GLIBC_2.xx not found".
          #
          # To avoid this, download and install ONLY prebuilt manylinux wheels for CPython 3.9.
          rm -rf .wheelhouse
          python -m pip download \
            --dest .wheelhouse \
            --only-binary=:all: \
            --platform manylinux2014_x86_64 \
            --python-version 39 \
            --implementation cp \
            --abi cp39 \
            -r backend/requirements.txt

          python -m pip install \
            --no-index \
            --find-links .wheelhouse \
            -r backend/requirements.txt \
            --target .python_packages/lib/site-packages

      - name: Create deploy.zip (backend/ + .python_packages/)
        shell: bash
        run: |
          set -euo pipefail
          rm -f deploy.zip

          # Do NOT include a .deployment file. The `project = backend` directive
          # causes Kudu to extract only the backend/ contents to wwwroot (flattening
          # the directory structure), which makes `cd /home/site/wwwroot/backend` fail
          # and also discards .python_packages/ since it's outside the project scope.

          zip -r deploy.zip backend .python_packages \
            -x "backend/__pycache__/*" \
               "backend/.pytest_cache/*" \
               "backend/**/__pycache__/*" \
               "backend/**/.pytest_cache/*" \
               "backend/tests/*"

      - name: Validate deploy.zip structure
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import sys, zipfile

          z = zipfile.ZipFile('deploy.zip')
          bad = []
          for name in z.namelist():
              if name.startswith('backend/') or name == 'backend/':
                  continue
              if name.startswith('.python_packages/') or name == '.python_packages/':
                  continue
              bad.append(name)

          if bad:
              print('ERROR: deploy.zip contains unexpected entries (allowed: backend/ and .python_packages/):')
              for n in bad[:50]:
                  print(' -', n)
              sys.exit(1)

          # Verify backend/app/main.py exists (sanity check for startup command)
          if 'backend/app/main.py' not in z.namelist():
              print('ERROR: deploy.zip missing backend/app/main.py')
              sys.exit(1)

          print('OK: deploy.zip contains backend/ and .python_packages/')
          PY

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          # Support both the "standard" secret names and the Azure-generated ones.
          client-id: ${{ secrets.AZURE_CLIENT_ID || secrets.AZUREAPPSERVICE_CLIENTID_426D9D8CF5E44278B95832DF7A8B952C }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID || secrets.AZUREAPPSERVICE_TENANTID_86103DA9D503455CBA1DD528317C4086 }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID || secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_2DB64B82AB4142F0BF1A20F53F83988A }}

      - name: Ensure site is started (Kudu needs a running site)
        shell: bash
        run: |
          set -euo pipefail

          state=$(az webapp show --resource-group "${AZURE_RESOURCE_GROUP}" --name "${AZURE_WEBAPP_NAME}" --query state -o tsv)
          echo "Current site state: ${state}"

          if [[ "${state}" != "Running" ]]; then
            az webapp start --resource-group "${AZURE_RESOURCE_GROUP}" --name "${AZURE_WEBAPP_NAME}"
            echo "Waiting 60s for SCM container to stabilize after start..."
            sleep 60
          fi

      - name: Pre-set safe startup command (before deploy)
        shell: bash
        run: |
          set -euo pipefail

          SAFE_STARTUP='cd /home/site/wwwroot/backend && gunicorn app.main:app --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:$PORT --timeout 120'
          az webapp config set \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --name "${AZURE_WEBAPP_NAME}" \
            --startup-file "${SAFE_STARTUP}"

      - name: Deploy (az webapp deploy)
        shell: bash
        run: |
          set -euo pipefail

          # Deploy with --async so the command returns as soon as the zip is uploaded
          # and Kudu starts extracting it.  The built-in sync polling of `az webapp deploy`
          # can falsely report "Site failed to start" even when the container is healthy
          # (startup probe takes ~150s; the deploy status API sometimes doesn't track the
          # successful restart).  We verify site health ourselves in the next step.
          az webapp deploy \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --name "${AZURE_WEBAPP_NAME}" \
            --type zip \
            --src-path deploy.zip \
            --clean true \
            --async true \
            --track-status false

          # Give Kudu time to rsync the zip contents to wwwroot (takes ~2-3 min for 6k+ files)
          echo "Waiting 180s for Kudu to extract the zip..."
          sleep 180

      - name: Purge stale Oryx build artifacts
        shell: bash
        run: |
          set -euo pipefail

          # If older Oryx-based deployments left artifacts at wwwroot, they can
          # override the new content at startup. Removing them post-deploy avoids
          # racing a zip deployment with a management/config operation.
          KUDU_URL="https://${AZURE_WEBAPP_NAME}.scm.azurewebsites.net"
          TOKEN=$(az account get-access-token --query accessToken -o tsv)

          for artifact in oryx-manifest.toml output.tar.zst; do
            echo "Deleting ${artifact} from wwwroot (if exists)..."
            curl -sf -X DELETE \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "If-Match: *" \
              "${KUDU_URL}/api/vfs/site/wwwroot/${artifact}" \
              && echo "  deleted." \
              || echo "  not found or already gone — OK."
          done

      - name: Run Alembic migrations (Kudu command)
        shell: bash
        run: |
          set -euo pipefail

          KUDU_URL="https://${AZURE_WEBAPP_NAME}.scm.azurewebsites.net"
          TOKEN=$(az account get-access-token --query accessToken -o tsv)

          CMD='cd /home/site/wwwroot/backend && export PYTHONPATH=/home/site/wwwroot/.python_packages/lib/site-packages && python3 -m alembic -c alembic.ini upgrade head'
          RESP=$(curl -sf -X POST \
            -H "Authorization: Bearer ${TOKEN}" \
            -H "Content-Type: application/json" \
            --data "$(printf '{\"command\":\"%s\",\"dir\":\"/home/site/wwwroot\"}' "${CMD}")" \
            "${KUDU_URL}/api/command")

          echo "${RESP}"

          MIGRATION_RESP="${RESP}" python3 - <<'PY'
          import json
          import os
          import sys

          raw = os.environ.get("MIGRATION_RESP", "")
          if not raw:
              print("Missing migration response payload")
              sys.exit(1)

          try:
              data = json.loads(raw)
          except Exception as exc:
              print(f"Failed to parse migration response JSON: {exc}")
              print(raw)
              sys.exit(1)

          output = data.get("Output", "")
          error = data.get("Error", "")
          exit_code = data.get("ExitCode")
            try:
              normalized_exit_code = int(exit_code) if exit_code is not None else 0
            except Exception:
              print(f"Unexpected ExitCode format: {exit_code}")
              sys.exit(1)

          if output:
              print(output)
          if error:
              print(error)

            if normalized_exit_code != 0:
              print(f"Alembic migration failed with ExitCode={exit_code}")
              sys.exit(1)

          if isinstance(error, str) and error.strip():
              print("Alembic migration reported stderr output; failing deployment")
              sys.exit(1)

          print("Alembic migration completed successfully")
          PY

      - name: Configure App Service build + startup (post-deploy)
        shell: bash
        env:
          AZURE_SUBSCRIPTION_ID_EFFECTIVE: ${{ secrets.AZURE_SUBSCRIPTION_ID || secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_2DB64B82AB4142F0BF1A20F53F83988A }}
        run: |
          set -euo pipefail

          if [[ -z "${AZURE_RESOURCE_GROUP}" || -z "${AZURE_WEBAPP_NAME}" ]]; then
            echo "Missing AZURE_RESOURCE_GROUP or AZURE_WEBAPP_NAME"
            exit 1
          fi

          az webapp config appsettings set \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --name "${AZURE_WEBAPP_NAME}" \
            --settings \
              SCM_DO_BUILD_DURING_DEPLOYMENT=false \
              WEBSITE_RUN_FROM_PACKAGE=0 \
              PYTHONPATH=/home/site/wwwroot/.python_packages/lib/site-packages

          # Startup command: start only Gunicorn. Migrations run in a dedicated step
          # before startup config to avoid startup probe timeout.
          # $PORT is expanded at runtime by the container.
          STARTUP_CMD='cd /home/site/wwwroot/backend && gunicorn app.main:app --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:$PORT --timeout 120'
          az webapp config set \
            --resource-group "${AZURE_RESOURCE_GROUP}" \
            --name "${AZURE_WEBAPP_NAME}" \
            --startup-file "${STARTUP_CMD}"

          # Optional EasyAuth configuration: only run when SWA_CLIENT_ID is provided.
          if [[ -n "${SWA_CLIENT_ID:-}" ]]; then
            if [[ -z "${AZURE_SUBSCRIPTION_ID_EFFECTIVE:-}" ]]; then
              echo "SWA_CLIENT_ID is set, but subscription id secret is missing; cannot configure authsettingsV2."
              exit 1
            fi

            az rest --method PUT \
              --url "https://management.azure.com/subscriptions/${AZURE_SUBSCRIPTION_ID_EFFECTIVE}/resourceGroups/${AZURE_RESOURCE_GROUP}/providers/Microsoft.Web/sites/${AZURE_WEBAPP_NAME}/config/authsettingsV2?api-version=2023-12-01" \
              --body "{\"properties\":{\"platform\":{\"enabled\":true,\"runtimeVersion\":\"~1\"},\"globalValidation\":{\"requireAuthentication\":false,\"unauthenticatedClientAction\":\"AllowAnonymous\"},\"identityProviders\":{\"azureStaticWebApps\":{\"enabled\":true,\"registration\":{\"clientId\":\"${SWA_CLIENT_ID}\"}}}}}"
          else
            echo "SWA_CLIENT_ID not set; skipping authsettingsV2 configuration."
          fi

          echo "Waiting 30s for config changes to apply..."
          sleep 30

      - name: Smoke test /health
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${AZURE_WEBAPP_URL}" ]]; then
            BASE_URL="${AZURE_WEBAPP_URL%/}"
          else
            BASE_URL="https://${AZURE_WEBAPP_NAME}.azurewebsites.net"
          fi

          HEALTH_URL="${BASE_URL}/health"
          echo "Checking: ${HEALTH_URL}"

          # The container needs ~2.5 min after deploy for cert init + Gunicorn startup.
          # 40 attempts × 10s = 400s (~6.5 min) gives plenty of headroom.
          for i in $(seq 1 40); do
            HTTP_CODE=$(curl -s -o /dev/null -w '%{http_code}' "${HEALTH_URL}" || echo "000")
            if [[ "${HTTP_CODE}" == "200" ]]; then
              echo "Health check passed (HTTP ${HTTP_CODE})"
              exit 0
            fi
            echo "Attempt ${i}/40 — HTTP ${HTTP_CODE}; retrying in 10s..."
            sleep 10
          done

          echo "Smoke test failed after 40 attempts (~400s)"
          exit 1
